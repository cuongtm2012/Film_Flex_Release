/**
 * Ophim Data Transformer
 * 
 * Transform dữ liệu từ Ophim API format sang database schema của hệ thống
 */

import type { OphimMovieDetailResponse } from './ophim-api';

/**
 * Transform Ophim movie data to internal database format
 * @param ophimData - Raw data from Ophim API
 * @returns Transformed data ready for database insertion
 */
export function transformOphimMovieToDbFormat(ophimData: OphimMovieDetailResponse) {
  const movie = ophimData.data.item;
  const episodes = ophimData.data.item.episodes || [];
  const cdnImageDomain = ophimData.data.APP_DOMAIN_CDN_IMAGE || 'https://img.ophim.live';

  // Validate required fields
  if (!movie || !movie.slug || !movie.name) {
    throw new Error('Invalid movie data: missing required fields (slug, name)');
  }

  // Transform movie data
  const transformedMovie = {
    // IDs and basic info
    movieId: movie._id || movie.slug, // Fallback to slug if _id is missing
    slug: movie.slug,
    name: movie.name,
    originName: movie.origin_name || movie.name,
    
    // Media URLs - prepend CDN domain if needed
    posterUrl: normalizeImageUrl(movie.poster_url || movie.thumb_url || '', cdnImageDomain),
    thumbUrl: normalizeImageUrl(movie.thumb_url || movie.poster_url || '', cdnImageDomain),
    trailerUrl: movie.trailer_url || null,
    
    // Classification
    type: normalizeMovieType(movie.type),
    status: movie.status || 'completed',
    quality: movie.quality || 'HD',
    lang: movie.lang || 'Vietsub',
    
    // Metadata
    year: movie.year || new Date().getFullYear(),
    time: movie.time || '',
    view: movie.view || 0,
    description: cleanDescription(movie.content || ''),
    
    // Episodes info
    episodeCurrent: movie.episode_current || 'Full',
    episodeTotal: movie.episode_total || '1',
    
    // Flags
    isCopyright: movie.is_copyright || false,
    subDocquyen: movie.sub_docquyen || false,
    chieurap: movie.chieurap || false,
    
    // Relations (as JSONB)
    categories: transformCategories(movie.category || []),
    countries: transformCountries(movie.country || []),
    actors: (movie.actor || []).join(', '),
    directors: (movie.director || []).join(', '),
    
    // Additional fields
    notify: movie.notify || '',
    showtimes: movie.showtimes || '',
    
    // Timestamps will be auto-generated by DB
  };

  // Transform episodes data
  const transformedEpisodes = transformEpisodes(movie.slug, episodes);

  return {
    movie: transformedMovie,
    episodes: transformedEpisodes,
  };
}

/**
 * Normalize movie type to match database enum
 */
function normalizeMovieType(type: string): string {
  const typeMap: Record<string, string> = {
    'single': 'movie',
    'series': 'series',
    'hoathinh': 'hoathinh',
    'tvshows': 'series',
    'tv_shows': 'series',
  };

  const normalized = type.toLowerCase().trim();
  return typeMap[normalized] || type;
}

/**
 * Normalize image URL - prepend CDN domain if relative path
 * Returns placeholder if URL is invalid or empty
 */
function normalizeImageUrl(url: string, cdnDomain: string): string {
  if (!url) {
    // Return placeholder image if no URL provided
    return '/placeholder-movie.svg';
  }
  
  // Already full URL - return as is
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  
  // Relative path - prepend CDN domain with correct path structure
  // Ophim CDN format: https://img.ophim.live/uploads/movies/{filename}
  const baseUrl = cdnDomain.endsWith('/') ? cdnDomain.slice(0, -1) : cdnDomain;
  return `${baseUrl}/uploads/movies/${url}`;
}

/**
 * Clean and truncate description
 */
function cleanDescription(description: string): string {
  if (!description) return '';
  
  // Remove excessive HTML tags
  let cleaned = description
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  // Truncate if too long (database limit or practical limit)
  const maxLength = 5000;
  if (cleaned.length > maxLength) {
    cleaned = cleaned.substring(0, maxLength) + '...';
  }
  
  return cleaned;
}

/**
 * Transform categories to JSONB format
 */
function transformCategories(categories: Array<{id: string; name: string; slug: string}>): any[] {
  return categories.map(cat => ({
    id: cat.id || cat.slug,
    name: cat.name,
    slug: cat.slug,
  }));
}

/**
 * Transform countries to JSONB format
 */
function transformCountries(countries: Array<{id: string; name: string; slug: string}>): any[] {
  return countries.map(country => ({
    id: country.id || country.slug,
    name: country.name,
    slug: country.slug,
  }));
}

/**
 * Transform episodes to database format
 */
function transformEpisodes(
  movieSlug: string, 
  episodes: Array<{
    server_name: string;
    is_ai?: boolean;
    server_data: Array<{
      name: string;
      slug: string;
      filename: string;
      link_embed: string;
      link_m3u8?: string;
    }>;
  }>
) {
  const transformedEpisodes: any[] = [];

  episodes.forEach((server) => {
    // Normalize server name for slug (remove special chars, spaces)
    const serverSlug = server.server_name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');

    server.server_data.forEach((episode, index) => {
      // Skip episodes without video links (bad data from API)
      if (!episode.link_embed && !episode.link_m3u8) {
        console.warn(`[Transformer] Skipping episode without video links: ${episode.name || episode.slug || index}`);
        return;
      }

      // Generate episode name if missing
      const episodeName = episode.name || episode.slug || `Episode ${index + 1}`;
      
      // Create unique slug using timestamp to prevent duplicates
      // Format: movieSlug-serverSlug-episodeSlug-timestamp
      const episodeSlug = episode.slug || episode.name || String(index + 1);
      const cleanEpisodeSlug = episodeSlug
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');
      
      const uniqueSlug = `${movieSlug}-${serverSlug}-${cleanEpisodeSlug}`;
      
      transformedEpisodes.push({
        movieSlug: movieSlug,
        serverName: server.server_name,
        name: episodeName,
        slug: uniqueSlug,
        filename: episode.filename || '',
        linkEmbed: episode.link_embed || '',
        linkM3u8: episode.link_m3u8 || '',
      });
    });
  });

  return transformedEpisodes;
}

/**
 * Validate transformed movie data before insertion
 */
export function validateMovieData(movieData: any): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Required fields
  if (!movieData.movieId) errors.push('Missing movieId');
  if (!movieData.slug) errors.push('Missing slug');
  if (!movieData.name) errors.push('Missing name');
  
  // URL validation - only validate if not placeholder
  if (movieData.posterUrl && 
      movieData.posterUrl !== '/placeholder-movie.svg' && 
      !isValidUrl(movieData.posterUrl)) {
    console.warn(`[Validator] Invalid posterUrl: ${movieData.posterUrl}, will use anyway`);
  }
  if (movieData.thumbUrl && 
      movieData.thumbUrl !== '/placeholder-movie.svg' && 
      !isValidUrl(movieData.thumbUrl)) {
    console.warn(`[Validator] Invalid thumbUrl: ${movieData.thumbUrl}, will use anyway`);
  }
  
  // Year validation
  if (movieData.year && (movieData.year < 1900 || movieData.year > 2100)) {
    errors.push('Invalid year');
  }
  
  // Type validation
  const validTypes = ['movie', 'series', 'hoathinh', 'tvshows'];
  if (movieData.type && !validTypes.includes(movieData.type)) {
    console.warn(`[Validator] Unknown movie type: ${movieData.type}, will use as-is`);
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Simple URL validation
 */
function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validate episode data
 */
export function validateEpisodeData(episodeData: any): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!episodeData.movieSlug) errors.push('Missing movieSlug');
  if (!episodeData.serverName) errors.push('Missing serverName');
  if (!episodeData.name) errors.push('Missing episode name');
  if (!episodeData.slug) errors.push('Missing episode slug');
  
  // Check video links - at least one should exist (already filtered in transformer)
  if (!episodeData.linkEmbed && !episodeData.linkM3u8) {
    errors.push('Missing both linkEmbed and linkM3u8 - need at least one video source');
  }
  
  // Validate M3U8 link if present
  if (episodeData.linkM3u8 && !episodeData.linkM3u8.endsWith('.m3u8')) {
    console.warn(`[Episode Validator] linkM3u8 doesn't end with .m3u8: ${episodeData.linkM3u8}`);
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Get movie statistics from transformed data
 */
export function getMovieStats(transformedData: ReturnType<typeof transformOphimMovieToDbFormat>) {
  return {
    movieName: transformedData.movie.name,
    slug: transformedData.movie.slug,
    type: transformedData.movie.type,
    year: transformedData.movie.year,
    episodeCount: transformedData.episodes.length,
    categories: transformedData.movie.categories.length,
    countries: transformedData.movie.countries.length,
  };
}
